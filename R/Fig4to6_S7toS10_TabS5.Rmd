---
fontsize: 11pt
geometry: margin=0.25in
output:
  html_document:
    keep_md: no
---

```{r DataPreparation, include=FALSE, eval=TRUE, warning=FALSE, message=FALSE}

########################################################################
######################## DATA PREPARATION ##############################
########################################################################

###Loading the packages
library(plyr)
library(tidyverse)
library(reshape2)
library(pander)
library(sqldf)
library(lazyeval)
library(lme4)
library(psych)
library(MASS)
library(scales)
library(gridExtra)
library(ggtern)
library(grid)
library(knitr)
library(kableExtra)
library(gtools)
library(ggalluvial)


#####################################
### Data loading and formatting  ###
####################################

### intSites <- read.csv('../Data/intSites.mergedSamples.collapsed.csv', header = TRUE)
intSites <- read.table(gzfile('../data/intSites.mergedSamples.collapsed.csv.gz'), sep = ',', header = TRUE)


intSites$timePoint <- as.character(intSites$timePoint)
intSites[which(intSites$timePoint == 'Y1'),]$timePoint <- 'M12'
intSites[which(intSites$timePoint == 'Y2'),]$timePoint <- 'M24'
intSites[which(intSites$timePoint == 'Y3'),]$timePoint <- 'M36'
intSites[which(intSites$timePoint == 'Y4'),]$timePoint <- 'M48'
intSites[which(intSites$timePoint == 'Y5'),]$timePoint <- 'M60'
intSites$timePoint <- factor(intSites$timePoint)



for(i in c('start', 'end', 'width', 'estAbund')) intSites[[i]] <- as.numeric(intSites[[i]]) 


#
# Read in the cell sorting cross over reports which are stored in a single file with records separated with '#%'.
# The counts table is identifiable by the key word COUNTS. 
#

options(stringsAsFactors = FALSE)
crossOverReports <- readChar('../data/crossOverReports.tsv', file.info('../data/crossOverReports.tsv')$size)
crossOverReports <- unlist(strsplit(crossOverReports, '#%'))
crossOverReports <- unlist(lapply(crossOverReports, function(x){
  source     <- ifelse(grepl('#source:', x), sub('\\t+$', '', str_match(x, '#source:\\s+(.+)')[2]), '')
  cellCounts <- as.numeric(str_match_all(str_match(x, 'initialCellCounts,(.+)')[2], '([\\d\\.]+)')[[1]][,2])
  psort <- as.numeric(str_match_all(str_match(x, 'pB_postsort,(.+)')[2], '([\\d\\.]+)')[[1]][,2])
  count_psort <-as.numeric(str_match_all(str_match(x, 'postsortCount,(.+)')[2], '([\\d\\.]+)')[[1]][,2])
  VCN <-as.numeric(str_match_all(str_match(x, 'VCN,(.+)')[2], '([\\d\\.]+)')[[1]][,2])
  DNA <-as.numeric(str_match_all(str_match(x, 'DNA,(.+)')[2], '([\\d\\.]+)')[[1]][,2])
  patient    <- str_match(x, '#(\\S+)')[2]
  timePoint  <- str_match(x, '#\\S+\\s+(\\S+)')[2]
  t          <- gsub('\\t+\\n', '\n', substr(x, regexpr('COUNTS', x)+7, nchar(x)))
  m          <- read.table(tc <- textConnection(t), header = TRUE, fill = TRUE, check.names = FALSE, sep='\t'); close(tc); 
  if(nrow(m) < 5 | length(m) < 5) return(NA)
  m <- m[1:5, 1:5]
  r <- list()
  r[[paste(patient, timePoint, source, sep='|')]] <- list(
    patient   = str_match(x, '#(\\S+)\\s+(\\S+)')[2],
    timePoint = str_match(x, '#(\\S+)\\s+(\\S+)')[3],
    source    = source,
    t         = t,
    table     = m,
    cellCount = cellCounts,
    psort     = psort,
    count_psort = count_psort,
    VCN = VCN,
    DNA = DNA)
  
  message('Read in ', names(r))
  r
}), recursive = FALSE)

crossOverReports <- crossOverReports[sapply(crossOverReports, is.list)]

#
# Subset the resulting list to include only those reports which will be used in the study.
#


all_samples <- c('WAS4|m12|Blood','WAS4|m36|Blood','WAS4|m48|Blood','WAS4|m60|Blood',
                 'WAS5|m55|Blood',
                 'bS/bS|m24|Blood',
                 'WAS2|m78|Blood',
                 'WAS7|m48|Blood',
                 'b0/bE|m48|Blood')


if(! all(all_samples %in% names(crossOverReports))) stop('All the requested crossover tables were not found.')
crossOverReports <- crossOverReports[all_samples]  


 ### proportion for each cell type
 prop_HD=c(0.2,0.2,0.2,0.2,0.2)


# Create a key to be used to update corrected abundances.
intSites$timePoint=tolower(intSites$timePoint)
intSites$key <- paste(intSites$posid, intSites$cellType, intSites$patient, intSites$timePoint)

 # Put the data in a wide format count table.
 assign(paste('liste_intSites_new_sup',0,sep=''),lapply(crossOverReports,function(x){  
   
    # Subset the intSite data to include only sites from a specific cell type and time point.
    i <- which(intSites$patient==x$patient &
               intSites$timePoint==x$timePoint &
               toupper(intSites$cellType) %in% toupper(names(x$table)))
    d <- intSites[i,]
    
    if(nrow(d) == 0) stop(paste0(x$patient, ' / ', x$timePoint, ' could not be found in the intSite data.'))
    
    message('Cell types in retrieved data subset(', x$patient, ' - ', x$timePoint, '): ',
            paste0(unique(d$celltype), collapse=', '))
    
    # Replace NA gene names with 'NONE' in case a function is sensitive to NA.
    if(length(which(is.na(d$nearestFeature))) > 0) d[which(is.na(d$nearestFeature)),]$nearestFeature <- 'NONE'
    
    # Reorganize the data to create an intSite / cell count table.
    d2 <- reshape2::dcast(d, posid ~ cellType, value.var='estAbund', fun.aggregate=function(x){x[1]}, fill=0)  
    
    # Add missing cell types.
    d2[names(x$table)[! toupper(names(x$table)) %in% toupper(names(d2))]] <- 0
    
    # Add nearest gene column.
    d2$gene <- intSites[match(d2$posid, intSites$posid),]$nearestFeature  
    
    # Add inFeature column.
    d2$inFeature <- intSites[match(d2$posid, intSites$posid),]$inFeature  
    
    # Reorganize the column headers to match Correction_CutData_new() input structure.
    d2 <- d2[,c(1,grep('gene',   names(d2), ignore.case = TRUE),
                 grep('BCELL',  names(d2), ignore.case = TRUE),
                 grep('MONO',   names(d2), ignore.case = TRUE),
                 grep('GRANULO', names(d2), ignore.case = TRUE),
                 grep('NKCELL', names(d2), ignore.case = TRUE),
                 grep('TCELL',  names(d2), ignore.case = TRUE),
                 grep('inFeature',  names(d2), ignore.case = TRUE)
                )]
    
    # Create a cell count column.
    d2$cellCount <-  apply(d2, 1, function(x){ sum(as.integer(x[3:7])) })
    
    # Rename the input columns.
    names(d2)=c("integrationSite", "gene", "Bcells", "Monocytes", "Granulocytes", "NKcells", "Tcells","inFeature", "cellCount")
    
    d2$integrationSite=as.character(d2$integrationSite)
    d2$gene=as.character(d2$gene)
    d2$key <- paste(c(x$patient, x$timePoint,x$source),collapse = "|") 
    intSites_new=d2
  
    return(intSites_new)
    } ))
  

  # Gather all the data sup0 (without threshold) in a unique dataframe.
  intSites_new_concat_sup0=do.call(rbind,liste_intSites_new_sup0)
  
# ------------------------------------------------------------------- #
  
  #Select the best samples
  samples <- c('WAS4|m12|Blood','WAS4|m48|Blood',
             'WAS5|m55|Blood',
             'bS/bS|m24|Blood',
             'b0/bE|m48|Blood')
  
  #########################
  ## Apply the threshold ##
  #########################
  
  ### Get the IS that had 6 or more cells for a cell type k at the tmpt.
  
  list_intSites_th_Initial=list()

  for(P in samples){
  
  pat=P
  liste=liste_intSites_new_sup0[pat]
  
  #Find the IS matching the criteria by patient/tmpt.
  IS=do.call(rbind, lapply(pat, function(s){
    L=liste[[s]]
    L$integrationSite=as.character(L$integrationSite)
    IS=subset(L,L$Bcells >=6| L$Monocytes >=6 | L$Granulocytes >=6 | L$NKcells >=6 | L$Tcells >=6)
    print(s)
    print(nrow(IS))
    IS
  }))
  
  IS_to_keep=unique(IS$integrationSite)
  
  #Apply the filter for the tmpt
  list_intSites_th_Initial[pat]=lapply(liste, function(x) subset(x,integrationSite%in%IS_to_keep))
  
  }

  # Gather all the data with the threshold in a unique dataframe.
  intSites_threshold_Initial=do.call(rbind,list_intSites_th_Initial)
  
  
  # ------------------------------------------------------------------- #

  #########################
  ## Apply the Correction ##
  #########################
  
 #load the correction function.  
 source('./AbundanceCorrection_2steps_Normalization_Steps.R')
  
  
 list_intSites_th_Corrected=lapply(crossOverReports[samples],function(cross){  
  
  if(cross$source == 'BoneMarrow') names(cross$table) <- paste0('BM_', names(cross$table))
    
    # Subset the intSites_threshold_Initial data to include only sites from a specific cell type and time point.
    i <- which(intSites_threshold_Initial$key == paste(c(cross$patient, cross$timePoint, cross$source),collapse = "|")) 
    df <- intSites_threshold_Initial[i,]
    
    #Use the correction function.
    correction=Correction_2steps_Normalization(x=cross,d2=df)
    data_corrected_final=correction$data_corrected_final

    # Rename the returned data frame to match the cell types in the intSites data frame.
    n <- c("integrationSite", "gene", "Bcells_corrected", "Monocytes_corrected", "Granulocytes_corrected",
           "NKcells_corrected", "Tcells_corrected")
    names(data_corrected_final) <- n
  
    intSites_new =dplyr::right_join(df,data_corrected_final,by=c('integrationSite','gene') )
    intSites_new = mutate(intSites_new,cellCount_corrected=rowSums(intSites_new[,grepl(names(intSites_new),
                                                                                       pattern='_corrected$')]))
  
    # Add proportions.
    prop = (intSites_new[,grepl("s_corrected",names(intSites_new))])/
      rowSums((intSites_new[,grepl("_corrected",names(intSites_new))]))
    names(prop) = c("Bcells_corrected_prop", "Monocytes_corrected_prop", "Granulocytes_corrected_prop",
                    "NKcells_corrected_prop", "Tcells_corrected_prop")
    intSites_new = cbind(intSites_new,prop)
    
    return(intSites_new)

  } ) 

 # Gather all the data with the threshold and corrected in a unique dataframe.
 intSites_threshold=do.call(rbind,list_intSites_th_Corrected)
 
 # ------------------------------------------------------------------- #
 
  ##############################################
  ### Apply the clustering to the patient   ### 
  ##############################################

 #load the tranformation and kmeans functions.
  source('./Kmeans_clustering.R')

  #Kmeans with correction

  liste_kmeans_results=list()
  for(s in samples){
  data_for_kmeans=subset(intSites_threshold,key==s)
  liste_kmeans_results[[s]]=KmeansClustering(data_for_kmeans,HD=prop_HD)
  }
  
  #Drop cluster with not enough IS : cluster K (1 IS)
  data_tofilter=liste_kmeans_results$`bS/bS|m24|Blood`$tableau
  liste_kmeans_results$`bS/bS|m24|Blood`$tableau=filter(data_tofilter,cluster!='K')

  data_tofilter_bis=liste_kmeans_results$`bS/bS|m24|Blood`$intSites_withKmeans
  liste_kmeans_results$`bS/bS|m24|Blood`$intSites_withKmeans=filter(data_tofilter_bis,cluster!='K')
  
```


```{r GlobalParameters, echo=FALSE, message=FALSE, warning=FALSE}

##################################################################### 
####################### GLOBAL PARAMETERS ###########################
##################################################################### 

# All Patient
keys=unique(intSites_threshold$key)
keys_lab=c(expression(atop(WAS4,m12)),expression(atop(WAS4,m48)),expression(atop(WAS5,m55)),
           expression(atop(beta*S/beta*S,m24)),expression(atop(beta*0/beta*E,m48)))
keys_lab_row=c(expression('WAS4~m12'),expression('WAS4~m48'),expression('WAS5~m55'),expression('beta*S/beta*S~m24'),
              expression('beta*0/beta*E~m48'))

# Sub-group of patient:
samples_evol=samples[1:2]
samples_evol_lab=c(expression(atop(WAS4,m12)),expression(atop(WAS4,m48)))
samples_evol_row=c(expression('WAS4~m12'),expression('WAS4~m48'))

samples=samples[-1]
samples_lab=c(expression(atop(WAS4,m48)),expression(atop(WAS5,m55)),expression(atop(beta*S/beta*S,m24)),
              expression(atop(beta*0/beta*E,m48)))
samples_lab_row=c(expression('WAS4~m48'),expression('WAS5~m55'),expression('beta*S/beta*S~m24'),
              expression('beta*0/beta*E~m48'))

# Determine general element themes for the plots:
th=theme_bw()+
   theme(text=element_text(family='ArialMT',size=32, colour='black',face='bold'),
         panel.grid.major = element_blank(),panel.grid.minor = element_blank(),
         strip.background=element_rect(fill=NA, color=NA),
         strip.text=element_text(family='ArialMT',size=28,colour='black',face='bold'),
         axis.text=element_text(family='ArialMT',size=28, colour='black',face='bold'),
         plot.title=element_text(family='ArialMT',size=33, colour='black',face='bold'))

th_small=theme_bw()+
   theme(text=element_text(family='ArialMT',size=24, colour='black',face='bold'),
         panel.grid.major = element_blank(),panel.grid.minor = element_blank(),
         strip.background=element_rect(fill=NA, color=NA),
         strip.text=element_text(family='ArialMT',size=22,colour='black',face='bold'),
         axis.text=element_text(family='ArialMT',size=22, colour='black',face='bold'),
         plot.title=element_text(family='ArialMT',size=25, colour='black',face='bold'))

# Fix the colors and order of all the possible clusters:
colors <- c(GMBKT='mediumorchid4',GMKT='darkorchid',GMBT='mediumpurple4',GMBK='mediumpurple',
            GBKT='magenta4',MBKT='hotpink4',
            GMB='forestgreen',GMK='deepskyblue3',GMT='thistle4',GBT='purple1',GBK='aquamarine3',GKT='thistle3',
            MBT='sienna3',MBK='honeydew3',MKT='lightpink4',BKT='coral2',
            MB='cornsilk3',MK='plum3',GB='green3',GK='cadetblue4',GM='deepskyblue4',GT='darkslateblue',MT='red4',
            BK='lightseagreen',BT='darkorange2',KT='hotpink3',
            T='red3',B='lightgoldenrod',K='turquoise2',G='royalblue4',M='gray22')

fac=c('GMBKT',"GMKT",'GMBT','GMBK','GBKT','MBKT','GMK','GMB','GMT','GBT','GBK','GKT',
      'MBK','MBT','MKT','BKT','MB','MK','MT', 'GM', 'GB','GK','GT', 'BK','BT','KT','G','M','B','K','T')

```

----------------------------------------------------------------------------------------

### *Main Figures*

----------------------------------------------------------------------------------------

##### Figure 4A : IS Repart.

```{r Fig4A, echo=FALSE, message=FALSE, warning=FALSE,fig.height=6, fig.width=12, dev='png',dpi=350}

  ## Get the data
  data=intSites_threshold
  data$cellCount=as.numeric(data$cellCount)
  high=c()

  for(p in samples) {
      high[p]=nrow(dplyr::filter(data,key==p))
  }

  dat=data.frame(high)
  dat=dplyr::mutate(dat,key=rownames(dat))

  #Name the patient.
  dat$key=factor(dat$key,levels=samples,labels=samples_lab)

  ## Plot 
  ggplot(dat,aes(x=key,y=high))+
  geom_bar(stat="identity",size=1,alpha=0.8)+
  geom_text(aes(label=high),position = position_stack(vjust = 0.5),
            size = 9,
            color='white',fontface="bold")+
  labs(x='',y='Unique IS number')+
  scale_x_discrete(breaks=levels(dat$key),labels=samples_lab)+
  th+theme(legend.position="bottom")

```


##### Figure 4B : % hematopoiesis.

```{r Fig4B, echo=FALSE, message=FALSE, warning=FALSE,fig.height=6, fig.width=12, dev='png',dpi=350}
  
  ## Get the data
  total=high=c()

  for(p in samples) {
  
  tot  = dplyr::filter(intSites_new_concat_sup0,key==p)
  thre = dplyr::filter(intSites_threshold,key==p)
    
  total[p]= sum(tot$cellCount)
  high[p]= sum(thre$cellCount)
  }

  dat=data.frame(cbind(total,high))
  dat$prop=dat$high/dat$total
  dat=dplyr::mutate(dat,key=rownames(dat))
  
  #Name the patient.
  dat$key=factor(dat$key,levels=samples,labels=samples_lab)

  ## Plot 
  ggplot(dat,aes(x=key,y=prop))+
  geom_bar(stat="identity",size=1,alpha=0.8)+
  geom_text(aes(label=scales::percent(round(prop,4))),
            size = 9,
            color='black',fontface="bold",vjust = -.5)+
  labs(fill = "",x='',y='% total hematopoiesis')+
  scale_x_discrete(breaks=dat$key,labels=samples_lab)+
  th+theme(legend.position="bottom")+
  scale_y_continuous(limits=c(0,0.8),labels=scales::percent) 

```


##### Figure 5A : IS Prop. Stacked bar

```{r Fig5A, echo=FALSE, message=FALSE, warning=FALSE, fig.height=11, fig.width=19, dev='png',dpi=350}
 
 ## Get the data
  data=do.call(rbind, lapply(samples, function(s){
    tableau = liste_kmeans_results[[s]]$tableau
    tableau = tableau[,grepl("transf",names(tableau))==FALSE]
    tableau$prop=tableau[,'clust_size']/sum(tableau[,'clust_size'])
    tableau$R2=paste(round(liste_kmeans_results[[s]]$R2,2)) 
    tableau
  }))
  
  data$key=factor(data$key,levels=samples,labels=samples_lab)
  data$cluster=factor(data$cluster,levels=fac)
  
  ## Plot
  ggplot(data)+geom_bar(aes(x=key, y=prop, fill=cluster,group=prop),stat='identity',color='white')+
  scale_fill_manual(values=colors)+
  scale_y_continuous(labels = percent_format())+
  scale_x_discrete(breaks=levels(data$key),labels=samples_lab)+
  labs(x='', y='IS proportion') +
  th+theme(axis.text.x=element_text(family='ArialMT',size=32, colour='black',face='bold'))+
  guides(fill=guide_legend(title='',override.aes = list(size=10)))
  
```


##### Figure 5B : Ternary plot

```{r Fig5B, echo=FALSE, message=FALSE, warning=FALSE, fig.height=20, fig.width=20,dev='png',dpi=350}

  ## Get the data
  plots=list()

  for(p in 1:4) {
     pat=samples[p]
     data=do.call(rbind, lapply(pat, function(x){
     a=liste_kmeans_results[[x]]$intSites_withKmeans
     a=a[c('key','cluster','cellCount_corrected',
         names(liste_kmeans_results[[x]]$intSites_withKmeans[,
         grep('_prop',names(liste_kmeans_results[[x]]$intSites_withKmeans))]))]
     #Rename the cell types corrected proportions.
      names(a)=c(names(a)[!grepl(x=names(a),'_prop')],'B','M','G','K','T')
      a
   }))

    data$cluster=factor(data$cluster,levels=fac)
    data$key=factor(data$key,levels=samples,labels=samples_lab)
  
    ## Plot
    C=ggtern(data,aes(G+M,T,B+K,group=cluster))+
      geom_count(aes(color= cluster,alpha=cellCount_corrected))+
      tern_limit(1.1,1.1,1.1) +xlab('GM')+ylab('T')+zlab('BK')+
      labs(title=samples_lab_row[p])+
      scale_color_manual(values = colors)+
      scale_size_continuous(breaks = round,range=c(4, 15))+
      scale_alpha(range=c(0.42,1),breaks=c(1,10,50,100,200,300),guide=FALSE)+
      guides(color=guide_legend(title='',override.aes = list(size=10),order=1),
             size=guide_legend(title='IS number'))+
      theme(legend.text = element_text(family='ArialMT',size=25,face='bold'),
            text=element_text(family='ArialMT',size=28,face='bold'),
            strip.background=element_rect(fill=NA, color=NA),
            axis.text=element_text(size=28,family='ArialMT',colour='black',face='bold'),
            axis.title=element_text(size=40,family='ArialMT',colour='black',face='bold'),
            panel.background =element_rect(fill = "white", colour = "black",size = 0.5, linetype = "solid"),
            panel.grid.major = element_line(colour = "gray60",size = 0.3),
            panel.grid.minor = element_line(colour = "gray60",size = 0.1), 
            panel.border = element_rect(colour = "black", size = 0.5,linetype = 1),
            plot.title = element_text(hjust = 0.5,family='ArialMT',size=35,colour = "black",face='bold'),
            tern.axis.arrow.show=TRUE, tern.axis.arrow=element_line(size=6),
            tern.axis.arrow.text=element_text(size=35,family='ArialMT',colour='black',face='bold'))

    plots[[p]]=C
  }

  ## Print all the ternary plots in the same panel.
  grid.arrange(grobs=plots)

```


##### Figure 6A : IS Repart.

```{r Fig6A, echo=FALSE, message=FALSE, warning=FALSE,fig.height=6, fig.width=8, dev='png',dpi=350}

  ## Get the data
  data=intSites_threshold
  data$cellCount=as.numeric(data$cellCount)
  high=c()

  for(p in samples_evol) {
    high[p]=nrow(dplyr::filter(data,key==p))
  }

  dat=data.frame(high)
  dat=dplyr::mutate(dat,key=rownames(dat))
  dat$key=factor(dat$key,levels=keys,labels=keys_lab)

  ## Plot
  ggplot(dat,aes(x=key,y=high))+
  geom_bar(stat="identity",size=1,alpha=0.8)+
  geom_text(aes(label=high),position = position_stack(vjust = 0.5),
            size = 9,
            color='white',fontface="bold")+
  labs(x='',y='Unique IS number')+
  scale_x_discrete(breaks=levels(dat$key),labels=keys_lab)+
  th_small+theme(legend.position="bottom")

```


##### Figure 6B : % hematopoiesis.

```{r Fig6B, echo=FALSE, message=FALSE, warning=FALSE,fig.height=6, fig.width=8, dev='png',dpi=350}
  
## Get the data
  total=high=c()

    for(p in samples_evol) {
  
    tot  = dplyr::filter(intSites_new_concat_sup0,key==p)
    thre = dplyr::filter(intSites_threshold,key==p)
    
    total[p]= sum(tot$cellCount)
    high[p]=sum(thre$cellCount)
    
    }

  dat=data.frame(cbind(total,high))
  dat$prop=dat$high/dat$total
  dat=dplyr::mutate(dat,key=rownames(dat))
  dat$key=factor(dat$key,levels=samples_evol)

  ## Plot 
  ggplot(dat,aes(x=key,y=prop))+
  geom_bar(stat="identity",size=1,alpha=0.8)+
  geom_text(aes(label=scales::percent(round(prop,4))),
            size = 9,
            color='black',fontface="bold",vjust = -.5)+
  labs(fill = "",x='',y='% total hematopoiesis')+
  scale_x_discrete(breaks=levels(dat$key),labels = keys_lab[1:2])+
  th_small+theme(legend.position="bottom")+
  scale_y_continuous(limits=c(0,0.8),labels=scales::percent) 

```


##### Figure 6C

```{r Fig6C, echo=FALSE, message=FALSE, warning=FALSE,fig.height=6, fig.width=8, dev='png',dpi=350}

  ## Get the data

  x='WAS4|m12|Blood'
  x_1='WAS4|m48|Blood'

  #Get the data for each tmpt.
  tmpt1=liste_kmeans_results[[x]]$intSites_withKmeans[,c('integrationSite','cluster','cellCount_corrected','key')]
  tmpt1$cluster=factor(tmpt1$cluster,levels=unique(tmpt1$cluster)[order(nchar(unique(tmpt1$cluster)),decreasing=TRUE)])

  tmpt2=liste_kmeans_results[[x_1]]$intSites_withKmeans[,c('integrationSite','cluster','cellCount_corrected','key')]
  tmpt2$cluster=factor(tmpt2$cluster,levels=unique(tmpt2$cluster)[order(nchar(unique(tmpt2$cluster)),decreasing=TRUE)])

  #Split according their status.
  commun=merge(tmpt1,tmpt2,by='integrationSite')
  only1=subset(tmpt1,integrationSite%in%setdiff(tmpt1$integrationSite,tmpt2$integrationSite))
  only2=subset(tmpt2,integrationSite%in%setdiff(tmpt2$integrationSite,tmpt1$integrationSite))

  #Check the values.
  if (nrow(only1)+nrow(commun)!=nrow(tmpt1)) print(' /!\ Problem with the rows for the tmpt1 /!\ ')
  if (nrow(only2)+nrow(commun)!=nrow(tmpt2)) print(' /!\ Problem with the rows for the tmpt2 /!\ ')


  #Comparing the cluster among the non-shared IS.
  tmpt1$indicator=ifelse(tmpt1$integrationSite%in%commun$integrationSite,'shared','not shared')
  tmpt2$indicator=ifelse(tmpt2$integrationSite%in%commun$integrationSite,'shared','not shared')

  #Total values
  total=as.data.frame(tmpt1 %>% 
                      count(indicator) %>% mutate(percent = n/sum(n)))
  total$cluster='Total'
  total$tmpt='WAS4\nm12'

  total2=as.data.frame(tmpt2 %>% 
                       count(indicator) %>% mutate(percent = n/sum(n)))
  total2$cluster='Total'
  total2$tmpt='WAS4\nm48'

  TOT=rbind(total,total2)
  TOT$cluster=factor(TOT$cluster,levels=c(fac,'Total'))

  ## Plot
  ggplot(TOT)+geom_bar(aes(x=tmpt,y=percent,fill=indicator),stat='identity',colour='black')+
  scale_y_continuous(labels = percent_format())+
  scale_fill_manual(values=c('white','black'))+
  th_small+theme(legend.position='bottom')+
  labs(x='',y='IS proportion',fill='')

```


##### Figure 6D : Ternary plot

```{r Fig6D, echo=FALSE, message=FALSE, warning=FALSE, fig.height=16, fig.width=22,dev='png',dpi=350}

  ## Get the data
  plots=list()

  for(p in 1:2) {
  
    pat=samples_evol[p]
  
    data=do.call(rbind, lapply(pat, function(x){
    a=liste_kmeans_results[[x]]$intSites_withKmeans
    a$cellCount_corrected=rowSums(a[,grepl(names(a),pattern='_corrected$')])
    a=a[c('key','cluster','cellCount_corrected',
        names(liste_kmeans_results[[x]]$intSites_withKmeans[,
              grep('_prop',names(liste_kmeans_results[[x]]$intSites_withKmeans))]))]
  #Rename the cell types corrected proportions.
  names(a)=c(names(a)[!grepl(x=names(a),'_prop')],'B','M','G','K','T')
  a
  }))
    
  data$cluster=factor(data$cluster,levels=fac)
  
  ## Plot
  E=ggtern(data,aes(G+M,T,B+K,group=cluster))+
    geom_count(aes(color= cluster,alpha=cellCount_corrected))+
    tern_limit(1.1,1.1,1.1) +xlab('GM')+ylab('T')+zlab('BK')+
    labs(title=samples_evol_row[p])+
    scale_color_manual(values = colors)+
    scale_size_continuous(breaks = round,range=c(4, 15))+
    scale_alpha(range=c(0.42,1),breaks=c(1,10,50,100,200,300),guide=FALSE)+
    guides(color=guide_legend(title='',override.aes = list(size=10),order=1),
           size=guide_legend(title='IS number'))+
    theme(legend.text = element_text(family='ArialMT',size=25,face='bold'),
            text=element_text(family='ArialMT',size=28,face='bold'),
            strip.background=element_rect(fill=NA, color=NA),
            axis.text=element_text(size=28,family='ArialMT',colour='black',face='bold'),
            axis.title=element_text(size=40,family='ArialMT',colour='black',face='bold'),
            panel.background =element_rect(fill = "white", colour = "black",size = 0.5, linetype = "solid"),
            panel.grid.major = element_line(colour = "gray60",size = 0.3),
            panel.grid.minor = element_line(colour = "gray60",size = 0.1), 
            panel.border = element_rect(colour = "black", size = 0.5,linetype = 1),
            plot.title = element_text(hjust = 0.5,family='ArialMT',size=35,colour = "black",face='bold'),
            tern.axis.arrow.show=TRUE, tern.axis.arrow=element_line(size=6),
            tern.axis.arrow.text=element_text(size=35,family='ArialMT',colour='black',face='bold'))

  plots[[p]]=E
  }

  ## Print all the ternary plots in the same panel.
  do.call("grid.arrange",c(plots,nrow=1))
       
```


##### Figure 6E

```{r Fig6E, echo=FALSE,fig.height=6, fig.width=8,message=FALSE,warning=FALSE}
# **** Need to run the chunk 'Fig6C' to have the data ****

  #TMPT 1.
  A=as.data.frame(tmpt1 %>% 
                  group_by(cluster)%>% 
                  count(indicator) %>% mutate(percent = n/sum(n)))
  A$tmpt='WAS4 m12'

  #TMPT 2.
  B=as.data.frame(tmpt2 %>% 
                  group_by(cluster)%>% 
                  count(indicator) %>% mutate(percent = n/sum(n)))
  B$tmpt='WAS4 m48'

  #ALL.
  E=rbind(A,B)
  E$cluster=factor(E$cluster,levels=c(fac,'Total'))

  ## Plot
  ggplot(E)+geom_bar(aes(x=cluster,y=percent,fill=indicator),stat='identity',colour='black')+
  facet_wrap(~tmpt,scales = 'free_x')+
  scale_y_continuous(labels = percent_format())+
  scale_fill_manual(values=c('white','black'))+
  th_small+theme(legend.position='bottom')+
  labs(x='',y='IS proportion',fill='')

```


##### Figure 6F : Alluvial diagramm

```{r Fig6F, echo=FALSE,fig.height=6, fig.width=8,message=FALSE,warning=FALSE}
# **** Need to run the chunk 'Fig6C' to have the data ****

  # Get the data
  a=rbind(tmpt1,tmpt2)
  commun=merge(tmpt1,tmpt2,by='integrationSite')

  commun_use=a[a$integrationSite%in%commun$integrationSite,]
  commun_use$Freq=rep(1,nrow(commun_use))
  commun_use$cluster=factor(commun_use$cluster,levels=fac)
  commun_use$key=factor(commun_use$key,levels=keys)

  # Alluvial diagram
   ggplot(commun_use,aes(y =Freq,x=key,stratum=cluster,alluvium=integrationSite))+
     geom_stratum(aes(fill = cluster),reverse = TRUE) +
     geom_flow(aes(fill = cluster,alpha=cellCount_corrected/max(cellCount_corrected)))+
     scale_x_discrete(breaks=levels(commun_use$key),labels=keys_lab[1:2])+
     th+
     theme(axis.text=element_text(size=23,family='ArialMT',colour='black',face='bold'))+
     scale_fill_manual(values=colors)+labs(fill='',y='IS number',alpha='',x='')+
     scale_alpha_continuous(range = c(0.5, 1))+
     guides(fill=guide_legend(title='',override.aes = list(size=10)),alpha=FALSE)

```


##### Figure 6G 

```{r Fig6G, echo=FALSE, message=FALSE, warning=FALSE, fig.height=22,fig.width=25,dev='png',dpi=350,out.width='\\textwidth'}

  ################################################
  ## Apply the Correction without the threshold ##
  ################################################

  
  list_sup0_Corrected=lapply(crossOverReports[all_samples],function(cross){  
  
   if(cross$source == 'BoneMarrow') names(cross$table) <- paste0('BM_', names(cross$table))
    
    # Subset the intSites_threshold_Initial data to include only sites from a specific cell type and time point.
    i <- which(intSites_new_concat_sup0$key == paste(c(cross$patient, cross$timePoint, cross$source),collapse = "|")) 
    df <- intSites_new_concat_sup0[i,]
    
    #Use the correction function.
    correction=Correction_2steps_Normalization(x=cross,d2=df)
    data_corrected_final=correction$data_corrected_final

    # Rename the returned data frame to match the cell types in the intSites data frame.
    n <- c("integrationSite", "gene", "Bcells_corrected", "Monocytes_corrected", "Granulocytes_corrected",
           "NKcells_corrected", "Tcells_corrected")
    names(data_corrected_final) <- n
  
    intSites_new =dplyr::right_join(df,data_corrected_final,by=c('integrationSite','gene') )
    intSites_new = mutate(intSites_new,cellCount_corrected=rowSums(intSites_new[,grepl(names(intSites_new),
                                                                                       pattern='_corrected$')]))
  
    # Add proportions.
    prop = (intSites_new[,grepl("s_corrected",names(intSites_new))])/
      rowSums((intSites_new[,grepl("_corrected",names(intSites_new))]))
    names(prop) = c("Bcells_corrected_prop", "Monocytes_corrected_prop", "Granulocytes_corrected_prop",
                    "NKcells_corrected_prop", "Tcells_corrected_prop")
    intSites_new = cbind(intSites_new,prop)
    
    return(intSites_new)

  } ) 

 # Gather all the data without the threshold and corrected in a unique dataframe.
 intSites_sup0_corrected=do.call(rbind,list_sup0_Corrected)
 
 ######################
 
 ## Get the longitudinal IS data corresponding to the m48 IS
 
 data = liste_kmeans_results$`WAS4|m48|Blood`$intSites_withKmeans
 cells = paste0(c('Bcells', 'Monocytes', 'Granulocytes', 'NKcells','Tcells'),'_corrected')

 #Top 15 of main clusters.
   data1 = data %>% filter(cluster %in% c('GBKT','GM','T'))%>%
   dplyr::select(integrationSite,gene,inFeature,cluster,key,cellCount_corrected,cells) %>%
   group_by(cluster) %>% 
   arrange(cluster, desc(cellCount_corrected)) %>% 
   filter(row_number()<=15)
 
 top=as.data.frame(data1)
 
 
 #Select the data matching the IS for the m12 tmpt.
 data_prev=list_sup0_Corrected$`WAS4|m12|Blood`
 data_prev=data_prev %>% dplyr::select(integrationSite,gene,inFeature,cells)
 
 top_alltmpt=left_join(top, data_prev, 
                       by = c('integrationSite' = 'integrationSite' ,  'gene'='gene' ,'inFeature' = 'inFeature'))
 
 #Select the data matching the IS for the m36 tmpt.
 data_prev=list_sup0_Corrected$`WAS4|m36|Blood`
 data_prev=data_prev %>% dplyr::select(integrationSite,gene,inFeature,cells)
 
 top_alltmpt=left_join(top_alltmpt, data_prev, 
                       by = c('integrationSite' = 'integrationSite' ,  'gene'='gene' ,'inFeature' = 'inFeature'))
 

 #Select the data matching the IS for the m60 tmpt.
 data_prev=list_sup0_Corrected$`WAS4|m60|Blood`
 data_prev=data_prev %>% dplyr::select(integrationSite,gene,inFeature,cells)
 
 top_alltmpt=left_join(top_alltmpt, data_prev, 
                       by = c('integrationSite' = 'integrationSite' ,  'gene'='gene' ,'inFeature' = 'inFeature'))
 
 
 colnames(top_alltmpt)<-c('IS','gene','inFeature','cluster','key','cellCount_corrected',
                          'B48','M48','G48','K48','T48',
                          'B12','M12','G12','K12','T12',
                          'B36','M36','G36','K36','T36',
                          'B60','M60','G60','K60','T60')

 #Get the cluster information.

  Col=colors[fac]
  names(Col)<-NULL
  top_alltmpt$cluster_c=factor(top_alltmpt$cluster,levels=fac,labels=Col)
  top_alltmpt = arrange(top_alltmpt,cluster_c)

  top_alltmpt$genesymb=ifelse(top_alltmpt$inFeature=='TRUE',paste0(top_alltmpt$gene,'*'),top_alltmpt$gene)
  rc <- as.character(top_alltmpt$cluster_c)

 ## Heatmap 
  library(gplots)
  library(RColorBrewer)
  par(cex.main=2)
  Colors=rev(brewer.pal(12,"RdBu"))
  Colors=c(colorRampPalette(Colors)(20))

  data=as.matrix(log10(top_alltmpt[,c(paste0('G',c(12,36,48,60)),
                                      paste0('M',c(12,36,48,60)),
                                      paste0('B',c(12,36,48,60)),
                                      paste0('K',c(12,36,48,60)),
                                      paste0('T',c(12,36,48,60)))]))
  row.names(data)<-top_alltmpt$genesymb

  labvec= rep(c(12,36,48,60),5)
  
  heatmap.2(data,
          Colv = NA, Rowv = FALSE, dendrogram="none",trace="none",tracecol="white",
          col =Colors,
          na.color="gray70",
          margins =c(14,16),
          lmat=rbind(c(5,0,4),c(3,1,2)),
          lhei=c( 0.25, 1.5),
          lwid = c(0.25,0.03,1),
          labCol = labvec,
          key.title =NA, key.par = list(cex=1.8),key.xlab="Log Abund.", 
          srtCol=360, adjCol = c(0.5,1),  
          cexRow = 2.8, cexCol=5,
          colsep=seq(from=4,to=4*5,by=4),
          rowsep = c(15,30,45),
          RowSideColors=rc)

 pos2 <- structure(list(x = c( 0.26,0.856), 
                        y = c(0.92, 0.92)),
                       .Names = c("x", "y"))
 
 #Add the cell types in the header.
  text(x=seq(pos2$x[1], pos2$x[2], len=5), y=rep(pos2$y[1],5)  ,
       cex=4,
       adj = 0,
       labels=c("G","M","B", "K","T") )


```

----------------------------------------------------------------------------------------

### *Supplementary figures*

----------------------------------------------------------------------------------------

##### _Supp Figure 7 : Kullback classif._

```{r SuppFig7 , echo=FALSE, message=FALSE, warning=FALSE, fig.height=20, fig.width=24,dev='png',dpi=350}

  ## KULLBACK distance function
  kl = function(prop1, prop2){
    sum(prop1 * log(prop1/prop2))
  }

  ## Get the values
  celltypes = c('G','M','B','K','T')

  i=0
  for ( x in samples){
    i=i+1

    #Get the variables.
    test=liste_kmeans_results[[x]]$intSites_withKmeans
    test=test[,c('key','cluster','cellCount_corrected',names(test[,grep('_prop',names(test))]))]

    #Order the columns.
    test=test[,c(1:3,6,5,4,7,8)]

    #Rename the prop corrected.
    names(test)=c(names(test)[!grepl(x=names(test),'_prop')],'G','M','B','K','T')

    #Initialisation.
    compositions = list()
    initial_comp=prop_HD
    nom = paste(celltypes,collapse = "")
    compositions[[nom]] = initial_comp

   #Determine each reference composition (blood,GMBK,...,K,T).
   for (m in 1:4){
    aeffacer = combn(1:5,m)

      for (k in 1:ncol(aeffacer)){
       comp = initial_comp
        comp[aeffacer[,k]] = initial_comp[aeffacer[,k]]/10
        comp = comp / sum(comp)
        nom = paste(celltypes[-aeffacer[,k]],collapse = "")
        compositions[[nom]] = comp
      }
    }

    distances = matrix(ncol=nrow(test),nrow=length(compositions))

    #Apply the distance between the data and the references.
    colnames(distances) = c(1:nrow(test))
    for (j in 1:nrow(test)){
     distances[,j] = unlist(lapply(compositions,kl,test[j,nchar(names(test))<2]))
    }

    #Get the minimum distance for each site and the corresponding reference.
    minimuns = names(compositions)[apply(distances,which.min,MARGIN = 2)]

    cells=test[,c('G','M','B','K','T','cellCount_corrected')]

    k=rep(x,length(minimuns))
    cluster=test$cluster
    data=cbind(k,minimuns,cluster,cells)
    assign(paste('dat',i,sep=''),data)
  }

  Kullback_dis=data.frame(rbind(dat1,dat2,dat3,dat4))

  ## We count the number of letters of each "type" to determine the number of lineages found (1 to 5) [ex: BKT --> 3]
  lin=nchar(Kullback_dis$minimuns)
  Kullback_dis=dplyr::mutate(Kullback_dis,lin)

  #Order & name the patients.
  Kullback_dis$k=factor(Kullback_dis$k,samples,labels=samples_lab_row)
  
  #Number of IS.
  nb_IS=aggregate(Kullback_dis$minimuns,list(Kullback_dis$k),length)
  Kullback=merge(Kullback_dis,nb_IS,by.x=c('k'),by.y=c('Group.1'))
  Kullback$labs=paste(Kullback$k,'~~~~(',Kullback$x,')', sep='')
  DAT=Kullback %>% 
      count(k,labs,minimuns,lin) %>%  group_by(labs)  %>% mutate(freq = n / sum(n)) %>% arrange(.,k,-n) %>%
      mutate(rank=paste0(minimuns,'_',n,'_',labs))

  DAT$rank=factor(DAT$rank,levels=unique(DAT$rank))
  DAT$labs=factor(DAT$labs,levels=unique(DAT$labs))

  ## Plot 
  ggplot(data=DAT,aes(x=rank,fill=as.factor(lin),y=freq))+
  geom_bar(alpha=0.80,stat="identity" ,width = 0.7)+
  facet_wrap(~labs,labeller = label_parsed,scales='free' ,ncol=1)+
  theme_bw()+labs(x='',y='% of Unique IS')+
  geom_text(aes(x=rank,y=freq,label=minimuns),size=6.3,fontface='bold',position = position_dodge(0.9),vjust=-0.3)+
  theme(text=element_text(family='ArialMT',size=25),
        axis.text.y=element_text(size=22.5,family='ArialMT',colour='black'),
        axis.text.x=element_blank(),
        legend.title=element_text(size=24),
        legend.text=element_text(family='ArialMT',size=22,colour='black'),
        panel.grid.major.x = element_blank(),
        panel.grid.minor=element_blank(),
        strip.background=element_rect(fill=NA, color=NA),
        strip.text=element_text(size=34),legend.position='bottom')+
  scale_x_discrete(breaks=levels(DAT$rank),labels=gsub('_.*','',levels(DAT$rank)))+ 
  scale_y_continuous(labels = scales::percent,limits=c(0,0.2))+ 
  guides(fill=guide_legend(title='Nb of lin.',override.aes = list(size=10)))

```


##### _Supp Figure 8A : Elbow plot_

```{r SuppFig8A,echo=FALSE, message=FALSE, warning=FALSE,fig.height=8, fig.width=16, dev='png',dpi=350}

  ## Get the data for each patient

  elb=matrix(NA,ncol=5,nrow=15)
  colnames(elb)=names(liste_kmeans_results)

  for (x in names(liste_kmeans_results)){
    elb[,x]=liste_kmeans_results[[x]]$elbow
  }

  #Change the format of the dataframes.  
  plotData=melt(elb)
 
  #Name and order the patients.
  plotData$Var2=factor(plotData$Var2,levels= keys,labels=keys_lab_row)

  ## Plot
  ggplot(plotData,aes(x=Var1,y=value,col=Var2))+ 
  geom_line()+ geom_point()+
  facet_wrap(~Var2,scales='free_x',labeller=label_parsed)+
  scale_x_continuous(breaks=1:15)+
  labs(y="R2", x="Number of clusters K")+   
  theme_bw()+guides(color=FALSE)+ 
  theme(text=element_text(family='ArialMT',size=32, colour='black'),panel.grid.major.y = element_blank(),
        panel.grid.minor=element_blank(),strip.background=element_rect(fill=NA, color=NA),
        strip.text=element_text(size=34),axis.text =element_text(family='ArialMT',size=18, colour='black'))
```


##### _Supp Figure 8B : Centroids_

```{r SuppFig8B, echo=FALSE, message=FALSE, warning=FALSE , fig.height=17, fig.width=22,dev='png',dpi=350}

##Get the data
data=do.call(rbind, lapply(samples, function(s){
  tableau = liste_kmeans_results[[s]]$tableau
  tableau = tableau[,grepl("transf",names(tableau))==FALSE]
  tableau$prop=round(tableau[,'clust_size']/sum(tableau[,'clust_size']),2)*100
  tableau$R2=paste(round(liste_kmeans_results[[s]]$R2,2)) 
  tableau
}))

colnames(data)=c('B','M','G','K','T',colnames(data)[6:ncol(data)])
data$key=factor(data$key,levels=samples,labels=samples_lab_row)
data$cluster=factor(data$cluster,levels=fac)

## Ternary plot
   ggtern(data,aes(G+M,T,B+K,group=cluster))+
   geom_point(aes(colour=cluster),shape = 1, size = 11, stroke = 3.2)+
   geom_point(aes(colour=cluster),shape = 16, size = 9.5,alpha=0.7)+
   tern_limit(1.1,1.1,1.1) +xlab('GM')+ylab('T')+zlab('BK')+
   facet_wrap(~key,nrow=2,labeller = label_parsed)+
   scale_fill_manual(values = colors)+
   scale_colour_manual(values = colors)+
   theme(legend.text = element_text(family='ArialMT',size=25,face='bold'),
         text=element_text(family='ArialMT',size=28,face='bold'),
         strip.background=element_rect(fill=NA, color=NA),
         strip.text=element_text(family='ArialMT',size=40,colour='black',face='bold'),
         axis.text=element_text(size=28,family='ArialMT',colour='black',face='bold'),
         axis.title=element_text(size=40,family='ArialMT',colour='black',face='bold'),
         panel.background =element_rect(fill = "white", colour = "black",size = 0.5, linetype = "solid"),
         panel.grid.major = element_line(colour = "gray60",size = 0.3),
         panel.grid.minor = element_line(colour = "gray60",size = 0.1), 
         panel.border = element_rect(colour = "black", size = 0.5,linetype = 1),
         plot.title = element_text(hjust = 0.5,family='ArialMT',size=35,colour = "black",face='bold'),
         tern.axis.arrow.show=TRUE, tern.axis.arrow=element_line(size=6),
         tern.axis.arrow.text=element_text(size=35,family='ArialMT',colour='black',face='bold'))+
    guides(colour=guide_legend(title=''))

```


##### _Supp Figure 9A : cell types abundances_


```{r SuppFig9A, echo=FALSE, results='asis', message=FALSE, warning=FALSE,fig.height=14,fig.width=14,dev='png',dpi=350}

  ## Get the data
  plots=list()
  
  for (pat in 1:length(samples)){
  
  p=samples[pat]
  
  data=liste_kmeans_results[[p]]$intSites_withKmeans
  data$cluster=factor(data$cluster,levels=fac)
  
  cells=paste0(c('Granulocytes','Tcells'),'_corrected')
  
  Values=lapply(cells, function(C){
    
    cat('\n')
    
    ## Data
    
    plotdata=data %>% dplyr::select(cells,key,cluster,integrationSite)
    plotdata$k=C
    
    #Formatting the data to have the nb of IS.
    nb_IS=aggregate(plotdata$integrationSite,list(plotdata$key,plotdata$cluster),length)
    data=merge(plotdata,nb_IS,by.x=c('key','cluster'),by.y=c('Group.1','Group.2'))
    
    #Order the clusters.
    data$labs=paste(data$cluster,'\n',data$x, sep='')
    ord=unique(data$labs[order(data$x,decreasing=T)])
    data$labs=factor(data$labs,levels=ord)
    
    ## Model
    
    fit_basic <- glm(get(C) ~ cluster,data=data, 
                     family=Gamma(link = "identity"))
    fit_basic_summary=summary(fit_basic)
    fit_basic_est=fit_basic_summary$coefficients[,1]
    fit_basic_pval=fit_basic_summary$coefficients[,4]
    
    #get the estimate
    dataF=data
    dataF$est=NA
    
    res=data.frame(estimate=fit_basic_est,pval=fit_basic_pval)
    res$stars=stars.pval(res$pval)
    res$cluster=gsub('cluster','',rownames(res))
    
    res_format=res %>% dplyr::select(cluster,estimate,pval)
    rownames(res_format)<-NULL
    table=res_format
    
    dataF=merge(dataF,res,all.x = T,by=c('cluster'))
    dataF$col=as.factor(ifelse(dataF$estimate>0,1,0))
  
    return(list('dataF'=dataF,'table'=table))
  })
  
  ## Table S5
  
  a=samples[pat]
  a=gsub('\\|Blood','',a)
  a=gsub('\\|',' ',a)
  a=gsub('b',"\u03B2",a)
  
  table=join(Values[[1]]$table,Values[[2]]$table,by='cluster')
  table[,2:5]=round(table[,2:5],10)
  table[table[,3]<2e-16,3]='<2e-16'
  table[table[,5]<2e-16,5]='<2e-16'
  
 #Show the models results. 
 print(kable(table, caption =a,align = "c", digits = 16, escape = FALSE, booktabs=TRUE) %>% 
          add_header_above(header=c(' ' = 1,'Granulocytes'=2,'Tcells'=2)) %>%
          kable_styling(c("striped", "bordered" ,"condensed")) %>%
          column_spec(1, bold = T))
  cat('\n')
  
  ## Plot
  
  Values=rbind(Values[[1]]$dataF,Values[[2]]$dataF)
  dataF=melt(Values,id.vars = c('cluster','key', 'integrationSite', 'k',  'x' , 'labs',
                             'est', 'estimate', 'pval', 'stars',  'col'))
  
  names=samples_lab[pat]
  
  labs=aggregate(list(Values$stars,Values$col),by=list(Values$k,Values$labs),unique)
  colnames(labs)=c('variable','labs','stars','col')

  dataF= dataF %>% dplyr::select(variable,labs,stars,col,value)
  
  dataF$variable=factor(dataF$variable,levels=cells,labels=gsub('_corrected','',cells))
  labs$variable=factor(labs$variable,levels=cells,labels=gsub('_corrected','',cells))
  
  #boxplot.
  box=
    ggplot(data=dataF)+geom_boxplot(aes(x=labs,y=value))+
    facet_wrap(~variable,labeller = label_parsed,ncol=1)+
    scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),
                  labels = trans_format("log10", math_format(10^.x)),
                  limits=c(1e-4,1e3))+
    labs(x='',y='cell type abundance (log)',title=a)+
    scale_colour_manual(values=c('steelblue4','firebrick3'))+
    theme_bw()+
    theme(text=element_text(family='Arial Bold',size=20),panel.grid.major = element_blank(),
          strip.background = element_rect(fill="grey99"),strip.text = element_text(size = 20),
          plot.title = element_text(hjust = 0.5))+guides(colour=FALSE)
   #Add the stars.
   box= box+geom_text(data=labs,aes(x=labs,y = 250, label =stars,colour=col),size=14) 
  
   #Add the x-axis colors according the clusters.
   gt=ggplotGrob(box)
   labels=gt$grobs[[6]]$children[[2]]$grobs[[2]]$children[[1]]$label
   gt$grobs[[6]]$children[[2]]$grobs[[2]]$children[[1]]$gp$col <- colors[gsub('\n.*','',labels)]
 
   plots[[pat]]=gt
  }

  ## Print all the ternary plots in the same panel.
  grid.arrange(grobs=plots,ncol=2)
```


##### _Supp Figure 9B : Cells repartition in clusters_

```{r SuppFig9B, echo=FALSE, message=FALSE, warning=FALSE , fig.height=12, fig.width=12,dev='png',dpi=350}

  ## Get the data
 data_val=do.call(rbind, lapply(samples, function(s){
 data= as.data.frame(liste_kmeans_results[[s]]$intSites_withKmeans)
 data = data %>% group_by(key,cluster) %>% summarise(G = sum(Granulocytes_corrected)/sum(cellCount_corrected),
                                                   M = sum(Monocytes_corrected)/sum(cellCount_corrected),
                                                   B = sum(Bcells_corrected)/sum(cellCount_corrected),
                                                   K = sum(NKcells_corrected)/sum(cellCount_corrected),
                                                   T = sum(Tcells_corrected)/sum(cellCount_corrected))
}))
  
plotData = melt(data_val)

 #Name & order the patient.
 plotData$key=factor(plotData$key,levels=samples,labels=samples_lab_row)

 #Order the celltypes for the plot.
 plotData$variable=factor(plotData$variable,levels=c('G','M','B','K','T'))

 #Order the clusters for the plot.
 plotData$cluster=factor(plotData$cluster,levels=fac)

 ## Plot

 ggplot(plotData, aes(x=cluster, y=value, fill=variable)) +
 facet_wrap(~key,scales = 'free',labeller = label_parsed,ncol=2)+
 geom_bar(stat='identity') +
 scale_fill_manual(values=c('royalblue1', 'gray48', 'lightgoldenrod', 'mediumturquoise', 'indianred1'))+
 scale_y_continuous(labels = percent_format())+
 labs(x='', y='Cell types proportion') +
 guides(fill=guide_legend(title='')) +th+
 theme(axis.text.y=element_text(size=20),
 axis.text.x=element_text(size=15),legend.position='bottom')+
 guides(fill=guide_legend(title='',override.aes = list(size=10)))
            
```


##### _Supp Fig. 10A _

```{r SuppFig10A, echo=FALSE, message=FALSE, warning=FALSE, fig.height=7, fig.width=8, dev='png',dpi=350}
 
  ## Get the data
  data=do.call(rbind, lapply(samples_evol, function(s){
    tableau = liste_kmeans_results[[s]]$tableau
    tableau = tableau[,grepl("transf",names(tableau))==FALSE]
    tableau$prop=tableau[,'clust_size']/sum(tableau[,'clust_size'])
    tableau$R2=paste(round(liste_kmeans_results[[s]]$R2,2)) 
    tableau
  }))
  
  data$key=factor(data$key,levels=samples_evol,labels=samples_evol_lab)
  data$cluster=factor(data$cluster,levels=fac)
                           
  ## Plot
  ggplot(data)+geom_bar(aes(x=key, y=prop, fill=cluster,group=prop),stat='identity',color='white')+
  scale_fill_manual(values=colors)+
  scale_y_continuous(labels = percent_format())+
  scale_x_discrete(breaks=levels(data$key),labels=samples_evol_lab)+
  labs(x='', y='IS proportion') +
  th+
  guides(fill=guide_legend(title='',override.aes = list(size=10)))

```


##### _Supp Fig. 10B  _

```{r SuppFig10B, echo=FALSE, message=FALSE, warning=FALSE, fig.height=7, fig.width=7, dev='png',dpi=350,out.height='80%',out.width='80%'}
  # **** Need to run the chunk 'Fig6C' & Fig6F' to have the data ****

  ## Get the data
  values=data.frame(table(commun$cluster.x,commun$cluster.y))
  names(values)=c(names(values)[1:2],'effectif')
  DF=data.frame(round(prop.table(table(commun$cluster.x,commun$cluster.y),1),3))

  tot=merge(values,DF,by=c('Var1','Var2'))

  #Replace the 0 by NAs to put them in grey.
  tot$Freq= replace(tot$Freq, tot$Freq<1e-5, NA)

  #If the value is 0, put no label.
  val_text=ifelse(tot$Freq>1e-5,paste(tot$Freq*100,'%'),'')
 
  ## Heatmap
  print(ggplot(tot)+geom_tile(aes(x=Var2,y=Var1,fill=Freq*100),colour='white',alpha=0.9)+
  geom_text(aes(x=Var2,y=Var1,label=val_text),cex=6,fontface='bold')+
  geom_label(aes(x=Var2,y=Var1,label=effectif,fill=Freq*100),cex=4.2,nudge_x=-0.3,nudge_y = 0.3)+
  scale_fill_distiller(palette = "Spectral")+th+
  labs(x='m24',y='m12',fill='% in row')+
  theme(legend.position="bottom",legend.text=element_text(size=18)))

```

