---
fontsize: 11pt
geometry: margin=0.25in
output:
  html_document:
    keep_md: no
---

```{r DataPrep, include=FALSE, eval=TRUE, warning=FALSE, message=FALSE}

########################################################################
######################## DATA PREPARATION ##############################
########################################################################


###Loading the packages
library(plyr)
library(tidyverse)
library(reshape2)
library(pander)
library(psych)
library(MASS)
library(scales)
library(gridExtra)
library(grid)
library(RColorBrewer)
library(arrangements)
library(gtable)

#####################################
### Data loading and formatting  ###
####################################


### intSites <- read.csv('../Data/intSites.mergedSamples.collapsed.csv', header = TRUE)
intSites <- read.table(gzfile('../data/intSites.mergedSamples.collapsed.csv.gz'), sep = ',', header = TRUE)


intSites$timePoint <- as.character(intSites$timePoint)
intSites[which(intSites$timePoint == 'Y1'),]$timePoint <- 'M12'
intSites[which(intSites$timePoint == 'Y2'),]$timePoint <- 'M24'
intSites[which(intSites$timePoint == 'Y3'),]$timePoint <- 'M36'
intSites[which(intSites$timePoint == 'Y4'),]$timePoint <- 'M48'
intSites[which(intSites$timePoint == 'Y5'),]$timePoint <- 'M60'
intSites$timePoint <- factor(intSites$timePoint)


for(i in c('start', 'end', 'width', 'estAbund')) intSites[[i]] <- as.numeric(intSites[[i]]) 


#
# Read in the cell sorting cross over reports which are stored in a single file with records separated with '#%'.
# The counts table is identifiable by the key word COUNTS. 
#

options(stringsAsFactors = FALSE)
crossOverReports <- readChar('../data/crossOverReports.tsv', file.info('../data/crossOverReports.tsv')$size)
crossOverReports <- unlist(strsplit(crossOverReports, '#%'))
crossOverReports <- unlist(lapply(crossOverReports, function(x){
  source     <- ifelse(grepl('#source:', x), sub('\\t+$', '', str_match(x, '#source:\\s+(.+)')[2]), '')
  cellCounts <- as.numeric(str_match_all(str_match(x, 'initialCellCounts,(.+)')[2], '([\\d\\.]+)')[[1]][,2])
  psort <- as.numeric(str_match_all(str_match(x, 'pB_postsort,(.+)')[2], '([\\d\\.]+)')[[1]][,2])
  count_psort <-as.numeric(str_match_all(str_match(x, 'postsortCount,(.+)')[2], '([\\d\\.]+)')[[1]][,2])
  VCN <-as.numeric(str_match_all(str_match(x, 'VCN,(.+)')[2], '([\\d\\.]+)')[[1]][,2])
  DNA <-as.numeric(str_match_all(str_match(x, 'DNA,(.+)')[2], '([\\d\\.]+)')[[1]][,2])
  patient    <- str_match(x, '#(\\S+)')[2]
  timePoint  <- str_match(x, '#\\S+\\s+(\\S+)')[2]
  t          <- gsub('\\t+\\n', '\n', substr(x, regexpr('COUNTS', x)+7, nchar(x)))
  m          <- read.table(tc <- textConnection(t), header = TRUE, fill = TRUE, check.names = FALSE, sep='\t'); close(tc); 
  if(nrow(m) < 5 | length(m) < 5) return(NA)
  m <- m[1:5, 1:5]
  r <- list()
  r[[paste(patient, timePoint, source, sep='|')]] <- list(
    patient   = str_match(x, '#(\\S+)\\s+(\\S+)')[2],
    timePoint = str_match(x, '#(\\S+)\\s+(\\S+)')[3],
    source    = source,
    t         = t,
    table     = m,
    cellCount = cellCounts,
    psort     = psort,
    count_psort = count_psort,
    VCN = VCN,
    DNA = DNA)
  
  message('Read in ', names(r))
  r
}), recursive = FALSE)

crossOverReports <- crossOverReports[sapply(crossOverReports, is.list)]

#
# Subset the resulting list to include only those reports which will be used in the study.
#
samples <- c('WAS4|m12|Blood','WAS4|m48|Blood',
             'WAS5|m55|Blood',
             'bS/bS|m24|Blood',
             'b0/bE|m48|Blood')


if(! all(samples %in% names(crossOverReports))) stop('All the requested crossover tables were not found.')
crossOverReports <- crossOverReports[samples]  


 ### proportion for each cell type
 prop_HD=c(0.2,0.2,0.2,0.2,0.2)


# Create a key to be used to update corrected abundances.
intSites$timePoint=tolower(intSites$timePoint)
intSites$key <- paste(intSites$posid, intSites$cellType, intSites$patient, intSites$timePoint)

 # Put the data in a wide format count table.
  
  assign(paste('liste_intSites_new_sup',0,sep=''),lapply(crossOverReports,function(x){  
   
    # Subset the intSite data to include only sites from a specific cell type and time point.
    i <- which(intSites$patient==x$patient &
               intSites$timePoint==x$timePoint &
               toupper(intSites$cellType) %in% toupper(names(x$table)))
    d <- intSites[i,]
    
    if(nrow(d) == 0) stop(paste0(x$patient, ' / ', x$timePoint, ' could not be found in the intSite data.'))
    
    message('Cell types in retrieved data subset(', x$patient, ' - ', x$timePoint, '): ',
            paste0(unique(d$celltype), collapse=', '))
    
    # Replace NA gene names with 'NONE' in case a function is sensitive to NA.
    if(length(which(is.na(d$nearestFeature))) > 0) d[which(is.na(d$nearestFeature)),]$nearestFeature <- 'NONE'
    
    # Reorganize the data to create an intSite / cell count table.
    d2 <- reshape2::dcast(d, posid ~ cellType, value.var='estAbund', fun.aggregate=function(x){x[1]}, fill=0)  
    
    # Add missing cell types.
    d2[names(x$table)[! toupper(names(x$table)) %in% toupper(names(d2))]] <- 0
    
    # Add nearest gene column.
    d2$gene <- intSites[match(d2$posid, intSites$posid),]$nearestFeature  
    
    # Add inFeature column.
    d2$inFeature <- intSites[match(d2$posid, intSites$posid),]$inFeature  
    
    # Reorganize the column headers to match Correction_CutData_new() input structure.
    d2 <- d2[,c(1,grep('gene',   names(d2), ignore.case = TRUE),
                 grep('BCELL',  names(d2), ignore.case = TRUE),
                 grep('MONO',   names(d2), ignore.case = TRUE),
                 grep('GRANULO', names(d2), ignore.case = TRUE),
                 grep('NKCELL', names(d2), ignore.case = TRUE),
                 grep('TCELL',  names(d2), ignore.case = TRUE),
                 grep('inFeature',  names(d2), ignore.case = TRUE)
                )]
    
    # Create a cell count column.
    d2$cellCount <-  apply(d2, 1, function(x){ sum(as.integer(x[3:7])) })
    
    # Rename the input columns.
    names(d2)=c("integrationSite", "gene", "Bcells", "Monocytes", "Granulocytes", "NKcells", "Tcells","inFeature", "cellCount")
    
    d2$integrationSite=as.character(d2$integrationSite)
    d2$gene=as.character(d2$gene)
    d2$key <- paste(c(x$patient, x$timePoint,x$source),collapse = "|") 
    intSites_new=d2
  
    return(intSites_new)
    } ))
  

  # Gather all the data sup0 (without threshold) in a unique dataframe.
  intSites_new_concat_sup0=do.call(rbind,liste_intSites_new_sup0)
  
# ------------------------------------------------------------------- #
  
  #########################
  ## Apply the threshold ##
  #########################
  
### Get the IS that had 6 or more cells for a cell type k at the tmpt.
  
  list_intSites_th_Initial=list()

  for(P in samples){
  
  pat=P
  liste=liste_intSites_new_sup0[pat]
  
  #Find the IS matching the criteria by patient/tmpt.
  IS=do.call(rbind, lapply(pat, function(s){
    L=liste[[s]]
    L$integrationSite=as.character(L$integrationSite)
    IS=subset(L,L$Bcells >=6| L$Monocytes >=6 | L$Granulocytes >=6 | L$NKcells >=6 | L$Tcells >=6)
    print(s)
    print(nrow(IS))
    IS
  }))
  
  IS_to_keep=unique(IS$integrationSite)
  
  #Apply the filter for the tmpt
  list_intSites_th_Initial[pat]=lapply(liste, function(x) subset(x,integrationSite%in%IS_to_keep))
  
  }

  # Gather all the data with the threshold in a unique dataframe.
  intSites_threshold_Initial=do.call(rbind,list_intSites_th_Initial)
  
  
  # ------------------------------------------------------------------- #

  #########################
  ## Apply the Correction ##
  #########################
  
 #load the correction function.  
 source('./AbundanceCorrection_2steps_Normalization_Steps.R')
  
  
 list_intSites_th_Corrected=lapply(crossOverReports[samples],function(cross){  
    
    # Subset the intSites_threshold_Initial data to include only sites from a specific cell type and time point.
    i <- which(intSites_threshold_Initial$key == paste(c(cross$patient, cross$timePoint, cross$source),collapse = "|")) 
    df <- intSites_threshold_Initial[i,]
    
    #Use the correction function.
    correction=Correction_2steps_Normalization(x=cross,d2=df)
    data_corrected_final=correction$data_corrected_final

    # Rename the returned data frame to match the cell types in the intSites data frame.
    n <- c("integrationSite", "gene", "Bcells_corrected", "Monocytes_corrected", "Granulocytes_corrected",
           "NKcells_corrected", "Tcells_corrected")
    names(data_corrected_final) <- n
  
    intSites_new =dplyr::right_join(df,data_corrected_final,by=c('integrationSite','gene') )
    intSites_new = mutate(intSites_new,cellCount_corrected=rowSums(intSites_new[,grepl(names(intSites_new),
                                                                                       pattern='_corrected$')]))
  
    # Add proportions.
    prop = (intSites_new[,grepl("s_corrected",names(intSites_new))])/
      rowSums((intSites_new[,grepl("_corrected",names(intSites_new))]))
    names(prop) = c("Bcells_corrected_prop", "Monocytes_corrected_prop", "Granulocytes_corrected_prop",
                    "NKcells_corrected_prop", "Tcells_corrected_prop")
    intSites_new = cbind(intSites_new,prop)
    
    return(intSites_new)

  } ) 

# Gather all the data with the threshold and corrected in a unique dataframe.
 intSites_threshold=do.call(rbind,list_intSites_th_Corrected)
 
```


```{r GlobalParameters, echo=FALSE, message=FALSE, warning=FALSE}

##################################################################### 
####################### GLOBAL PARAMETERS ###########################
##################################################################### 

# All Patient
keys=unique(intSites_threshold$key)
keys_lab=c(expression(atop(WAS4,m12)),expression(atop(WAS4,m48)),expression(atop(WAS5,m55)),
           expression(atop(beta*S/beta*S,m24)),expression(atop(beta*0/beta*E,m48)))

# Sub-group of patient:
samples_evol=samples[1:2]
samples_evol_lab=c(expression(atop(WAS4,m12)),expression(atop(WAS4,m48)))

samples=samples[-1]
samples_lab=c(expression('WAS4~m48'),expression('WAS5~m55'),expression('beta*S/beta*S~m24'),
              expression('beta*0/beta*E~m48'))

# Determine general element themes for the plots:
th_small=theme_bw()+
  theme(text=element_text(family='ArialMT',size=26, colour='black',face='bold'),
        panel.grid.major = element_blank(),panel.grid.minor = element_blank(),
        strip.background=element_rect(fill=NA, color=NA),
        strip.text=element_text(family='ArialMT',size=27,colour='black',face='bold'),
        axis.text=element_text(family='ArialMT',size=19, colour='black',face='bold'),
        plot.title=element_text(family='ArialMT',size=27, colour='black',face='bold'))

celltype=c('Granulocytes_corrected','Monocytes_corrected','Bcells_corrected','NKcells_corrected','Tcells_corrected')

```


##### Figure 4C

```{r Fig4C, echo=FALSE, eval=TRUE,fig.width=20,fig.height=5.5,warning=FALSE,message=FALSE}

  ## Get the data
  corr_plot=list()

  for(i in 1:length(samples)){
    pat=samples[i]
    data=list_intSites_th_Corrected[[pat]]
    correlation=cor(data[,c(13,12,11,14,15)])

  #Only keep  half of the correlations (symetric matrix).
  cormat=correlation
  cormat[lower.tri(cormat)] <- NA

  #Format the data.
  melted_cormat <- melt(cormat, na.rm = TRUE)
  melted_cormat$Var1=factor(melted_cormat$Var1,levels=celltype,labels=c('G','M','B','K','T'))
  melted_cormat$Var2=factor(melted_cormat$Var2,levels=celltype,labels=c('G','M','B','K','T'))
  
    
  names=gsub('\\|Blood','',pat)
  names=gsub('\\|',' ',names)
  names=gsub('b',"\u03B2",names)

  ## Heatmap
 
  g=ggplot(data = melted_cormat, aes(Var2, Var1, fill = value))+
    geom_tile(color = "white")+
    scale_fill_gradientn(colours = brewer.pal(10,"RdBu"),limit=c(-1,1),breaks=c(-1,-0.5,0,0.5,1))+
    labs(title=names,x='',y='',fill='')+
    th_small+ theme(plot.title = element_text(hjust = 0.5))+
    coord_fixed()

  corr_plot[[pat]]=g
  }

  ## Print all the heatmaps in the same panel. 
  grid.arrange(grobs=corr_plot,nrow=1)
 
```


##### Figure 4D - 4E - 4F

```{r Fig4DtoF, echo=FALSE, eval=TRUE,fig.width=24,fig.height=7,warning=FALSE,message=FALSE}

 ## Get the data
 A=B=a=b=list()

 combi=permutations(x = celltype, freq = c(2, 2, 2,2,2), k = 2)
 combi=t(combi)
 indic=indic_tot=list()

  for (i in 1:ncol(combi)){
  
  c1=combi[1,i]
  c2=combi[2,i]

    for (x in 1:4 ){
    
    p=samples[x]
    data_pat=subset(list_intSites_th_Corrected[[p]])

    data=data_pat[,c('integrationSite',c1,c2)]
    colnames(data)=c('IS','c1','c2')
    data_sub=subset(data,data$c1>0|data$c2>0)
  
    if (c1 =="NKcells"){n_c1='K'}
    n_c1=substr(c1, 1,1)
  
    if (c2 =="NKcells"){n_c1='K'}
    n_c2=substr(c2, 1,1)
  
    # correlation study
    r_cut=round(cor(data_sub$c1,data_sub$c2),3)
  
    indic[[p]]=c(c1,c2,r_cut)
  
    #Bias plot on the data with threshold
  
    data_thr_study=data_sub
    data_thr_study$quotient=data_thr_study$c2/data_thr_study$c1
    data_thr_study$cat=cut(data_thr_study$quotient,
                         breaks=c(-Inf,0.1,0.2,0.33,0.66,1.5,3,5,10,Inf),right=T,include.lowest = TRUE)
  
  ## Plot
  G=ggplot( data_thr_study)+
    geom_bar(aes(x=cat))+
    labs(y='IS number',x=n_c1)+
    scale_x_discrete(drop=FALSE,breaks=levels(data_thr_study$cat),
                     labels= c(">10", ">5", ">3",">1.5","1",">1.5",">3",">5",">10"))+
    th_small+theme(axis.text.x = element_text(angle = 90, hjust = 1))+
    theme(axis.title.x=element_text(hjust=0,family='ArialMT',size=30, colour='black',face='bold'))

  g = ggplotGrob(G)
  
  #Add the second x axis title. 
  g2 <- gtable_add_grob(g, textGrob(n_c2, x=1, hjust=1,
                                    gp=gpar(fontfamily='ArialMT',fontsize=30, col='black',fontface='bold')),
                      t=8, l=4, b=8, r=4, name="right-title")

  B[[p]]=g2

  }
  
  indic_tot[[i]]=indic
 
  # Show some combinaisons
 if (i %in% c(2,3,5)){
  grid.arrange(grobs=c(A,B),ncol=4,top=textGrob(paste('\n \n',c1,'vs',c2,'\n'),gp=gpar(fontface = 'bold',cex=2)))
 }
}

```




